#!/usr/bin/env python3
"""
ä»£ç çŸ¥è¯†å›¾è°± - å­˜å‚¨æœåŠ¡

å°†ä»£ç åˆ†æç»“æœå­˜å‚¨åˆ°æ•°æ®åº“ï¼Œæ”¯æŒé«˜æ•ˆæŸ¥è¯¢
"""

from typing import List, Dict, Any, Optional
from datetime import datetime
from sqlalchemy import Column, String, Integer, Text, JSON, DateTime, ForeignKey, Index, func
from sqlalchemy.orm import Session, relationship
from sqlalchemy.ext.declarative import declarative_base

try:
    from .models.tables import Base as ProjectBase
except ImportError:
    # å¦‚æœç›¸å¯¹å¯¼å…¥å¤±è´¥ï¼Œå°è¯•ç»å¯¹å¯¼å…¥
    try:
        from src.mcp_core.models.tables import Base as ProjectBase
    except ImportError:
        # åˆ›å»ºä¸€ä¸ªç©ºçš„Baseï¼ˆå…¼å®¹æ€§ï¼‰
        ProjectBase = declarative_base()

from .code_analyzer import CodeEntity, CodeRelation

Base = declarative_base()


# ==================== æ•°æ®æ¨¡å‹ ====================

class CodeProject(Base):
    """ä»£ç é¡¹ç›®"""
    __tablename__ = "code_projects"
    __table_args__ = {"mysql_charset": "utf8mb4", "mysql_collate": "utf8mb4_unicode_ci"}

    project_id = Column(String(64), primary_key=True)
    name = Column(String(255), nullable=False)
    path = Column(String(512), nullable=False)
    language = Column(String(32), default="python")
    version = Column(String(64))
    description = Column(Text)

    # ç»Ÿè®¡ä¿¡æ¯
    total_files = Column(Integer, default=0)
    total_lines = Column(Integer, default=0)
    total_entities = Column(Integer, default=0)
    total_relations = Column(Integer, default=0)

    # åˆ†æçŠ¶æ€
    status = Column(String(32), default="pending")  # pending, analyzing, completed, failed
    analyzed_at = Column(DateTime)
    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())

    # å…ƒæ•°æ®
    meta_data = Column(JSON, default=dict)


class CodeEntityModel(Base):
    """ä»£ç å®ä½“"""
    __tablename__ = "code_entities"
    __table_args__ = (
        Index('idx_project_type', 'project_id', 'entity_type'),
        Index('idx_qualified_name', 'qualified_name'),
        Index('idx_file_path', 'file_path'),
        {"mysql_charset": "utf8mb4", "mysql_collate": "utf8mb4_unicode_ci"}
    )

    entity_id = Column(String(64), primary_key=True)
    project_id = Column(String(64), ForeignKey('code_projects.project_id', ondelete='CASCADE'), nullable=False)

    # åŸºæœ¬ä¿¡æ¯
    entity_type = Column(String(32), nullable=False)  # class, function, method, variable, module
    name = Column(String(255), nullable=False)
    qualified_name = Column(String(512), nullable=False)

    # ä½ç½®ä¿¡æ¯
    file_path = Column(String(512), nullable=False)
    line_number = Column(Integer, nullable=False)
    end_line = Column(Integer)

    # è¯¦ç»†ä¿¡æ¯
    docstring = Column(Text)
    signature = Column(String(512))
    parent_id = Column(String(64))

    # å…ƒæ•°æ®
    meta_data = Column(JSON, default=dict)

    # å‘é‡è¡¨ç¤ºï¼ˆç”¨äºè¯­ä¹‰æœç´¢ï¼‰
    embedding = Column(Text)  # JSONåºåˆ—åŒ–çš„å‘é‡

    created_at = Column(DateTime, server_default=func.now())


class CodeRelationModel(Base):
    """ä»£ç å…³ç³»"""
    __tablename__ = "code_relations"
    __table_args__ = (
        Index('idx_project_relation', 'project_id', 'relation_type'),
        Index('idx_source', 'source_id'),
        Index('idx_target', 'target_id'),
        {"mysql_charset": "utf8mb4", "mysql_collate": "utf8mb4_unicode_ci"}
    )

    relation_id = Column(String(64), primary_key=True)
    project_id = Column(String(64), ForeignKey('code_projects.project_id', ondelete='CASCADE'), nullable=False)

    source_id = Column(String(64), nullable=False)
    target_id = Column(String(64), nullable=False)
    relation_type = Column(String(32), nullable=False)  # calls, imports, inherits, uses, contains

    # å…ƒæ•°æ®
    meta_data = Column(JSON, default=dict)

    created_at = Column(DateTime, server_default=func.now())


class CodeKnowledge(Base):
    """ä»£ç çŸ¥è¯†æ¡ç›®ï¼ˆé«˜å±‚æ¬¡ç†è§£ï¼‰"""
    __tablename__ = "code_knowledge"
    __table_args__ = (
        Index('idx_project_category', 'project_id', 'category'),
        {"mysql_charset": "utf8mb4", "mysql_collate": "utf8mb4_unicode_ci"}
    )

    knowledge_id = Column(String(64), primary_key=True)
    project_id = Column(String(64), ForeignKey('code_projects.project_id', ondelete='CASCADE'), nullable=False)

    category = Column(String(64), nullable=False)  # architecture, pattern, workflow, concept
    title = Column(String(255), nullable=False)
    description = Column(Text)

    # å…³è”å®ä½“
    related_entities = Column(JSON, default=list)  # ç›¸å…³å®ä½“IDåˆ—è¡¨

    # å…ƒæ•°æ®
    meta_data = Column(JSON, default=dict)

    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())


# ==================== çŸ¥è¯†å›¾è°±å­˜å‚¨æœåŠ¡ ====================

class CodeKnowledgeGraphService:
    """ä»£ç çŸ¥è¯†å›¾è°±å­˜å‚¨æœåŠ¡"""

    def __init__(self, db: Session):
        self.db = db

    def create_project(self,
                      project_id: str,
                      name: str,
                      path: str,
                      language: str = "python",
                      **kwargs) -> CodeProject:
        """åˆ›å»ºé¡¹ç›®"""
        project = CodeProject(
            project_id=project_id,
            name=name,
            path=path,
            language=language,
            **kwargs
        )
        self.db.add(project)
        self.db.commit()
        self.db.refresh(project)
        return project

    def store_analysis_result(self,
                              project_id: str,
                              entities: List[Dict[str, Any]],
                              relations: List[Dict[str, Any]],
                              stats: Dict[str, Any]) -> None:
        """å­˜å‚¨åˆ†æç»“æœ"""

        # æ›´æ–°é¡¹ç›®çŠ¶æ€
        project = self.db.query(CodeProject).filter_by(project_id=project_id).first()
        if not project:
            raise ValueError(f"é¡¹ç›®ä¸å­˜åœ¨: {project_id}")

        project.status = "analyzing"
        project.total_files = stats.get("total_files", 0)
        project.total_lines = stats.get("total_lines", 0)
        project.total_entities = len(entities)
        project.total_relations = len(relations)
        self.db.commit()

        # æ‰¹é‡æ’å…¥å®ä½“
        print(f"ğŸ’¾ å­˜å‚¨ {len(entities)} ä¸ªå®ä½“...")
        for i, entity_data in enumerate(entities):
            if i % 100 == 0:
                print(f"   è¿›åº¦: {i}/{len(entities)}")

            entity = CodeEntityModel(
                entity_id=entity_data["id"],
                project_id=project_id,
                entity_type=entity_data["type"],
                name=entity_data["name"],
                qualified_name=entity_data["qualified_name"],
                file_path=entity_data["file_path"],
                line_number=entity_data["line_number"],
                end_line=entity_data.get("end_line"),
                docstring=entity_data.get("docstring"),
                signature=entity_data.get("signature"),
                parent_id=entity_data.get("parent_id"),
                meta_data=entity_data.get("metadata", {})
            )
            self.db.add(entity)

        self.db.commit()
        print(f"âœ“ å®ä½“å­˜å‚¨å®Œæˆ")

        # æ‰¹é‡æ’å…¥å…³ç³»
        print(f"ğŸ’¾ å­˜å‚¨ {len(relations)} ä¸ªå…³ç³»...")
        for i, relation_data in enumerate(relations):
            if i % 100 == 0:
                print(f"   è¿›åº¦: {i}/{len(relations)}")

            import hashlib
            relation_id = hashlib.md5(
                f"{relation_data['source_id']}:{relation_data['target_id']}:{relation_data['relation_type']}".encode()
            ).hexdigest()[:16]

            relation = CodeRelationModel(
                relation_id=relation_id,
                project_id=project_id,
                source_id=relation_data["source_id"],
                target_id=relation_data["target_id"],
                relation_type=relation_data["relation_type"],
                meta_data=relation_data.get("metadata", {})
            )
            self.db.add(relation)

        self.db.commit()
        print(f"âœ“ å…³ç³»å­˜å‚¨å®Œæˆ")

        # æ›´æ–°é¡¹ç›®çŠ¶æ€
        project.status = "completed"
        project.analyzed_at = datetime.now()
        self.db.commit()

        print(f"âœ… é¡¹ç›®åˆ†æç»“æœå·²å­˜å‚¨: {project_id}")

    def query_entity(self, project_id: str, entity_id: str) -> Optional[CodeEntityModel]:
        """æŸ¥è¯¢å®ä½“"""
        return self.db.query(CodeEntityModel).filter_by(
            project_id=project_id,
            entity_id=entity_id
        ).first()

    def query_entities_by_type(self, project_id: str, entity_type: str) -> List[CodeEntityModel]:
        """æŒ‰ç±»å‹æŸ¥è¯¢å®ä½“"""
        return self.db.query(CodeEntityModel).filter_by(
            project_id=project_id,
            entity_type=entity_type
        ).all()

    def query_entities_by_file(self, project_id: str, file_path: str) -> List[CodeEntityModel]:
        """æŒ‰æ–‡ä»¶æŸ¥è¯¢å®ä½“"""
        return self.db.query(CodeEntityModel).filter_by(
            project_id=project_id,
            file_path=file_path
        ).all()

    def query_relations(self,
                       project_id: str,
                       source_id: Optional[str] = None,
                       target_id: Optional[str] = None,
                       relation_type: Optional[str] = None) -> List[CodeRelationModel]:
        """æŸ¥è¯¢å…³ç³»"""
        query = self.db.query(CodeRelationModel).filter_by(project_id=project_id)

        if source_id:
            query = query.filter_by(source_id=source_id)
        if target_id:
            query = query.filter_by(target_id=target_id)
        if relation_type:
            query = query.filter_by(relation_type=relation_type)

        return query.all()

    def trace_calls(self, project_id: str, entity_id: str, depth: int = 3) -> Dict[str, Any]:
        """è¿½è¸ªå‡½æ•°è°ƒç”¨é“¾"""

        def _trace_recursive(current_id: str, current_depth: int, visited: set) -> List[Dict]:
            if current_depth >= depth or current_id in visited:
                return []

            visited.add(current_id)

            # æŸ¥è¯¢å½“å‰å®ä½“è°ƒç”¨çš„å‡½æ•°
            relations = self.query_relations(
                project_id=project_id,
                source_id=current_id,
                relation_type="calls"
            )

            calls = []
            for rel in relations:
                target_entity = self.query_entity(project_id, rel.target_id)
                if target_entity:
                    call_info = {
                        "entity_id": target_entity.entity_id,
                        "name": target_entity.name,
                        "qualified_name": target_entity.qualified_name,
                        "file_path": target_entity.file_path,
                        "line_number": target_entity.line_number,
                        "depth": current_depth + 1,
                        "calls": _trace_recursive(target_entity.entity_id, current_depth + 1, visited)
                    }
                    calls.append(call_info)

            return calls

        root_entity = self.query_entity(project_id, entity_id)
        if not root_entity:
            return {"error": "Entity not found"}

        return {
            "root": {
                "entity_id": root_entity.entity_id,
                "name": root_entity.name,
                "qualified_name": root_entity.qualified_name,
                "file_path": root_entity.file_path,
                "line_number": root_entity.line_number
            },
            "call_tree": _trace_recursive(entity_id, 0, set())
        }

    def find_dependencies(self, project_id: str, entity_id: str) -> Dict[str, Any]:
        """æŸ¥æ‰¾å®ä½“ä¾èµ–"""

        # å‘å‰ä¾èµ–ï¼ˆè¿™ä¸ªå®ä½“ä¾èµ–è°ï¼‰
        outgoing = self.query_relations(project_id=project_id, source_id=entity_id)

        # å‘åä¾èµ–ï¼ˆè°ä¾èµ–è¿™ä¸ªå®ä½“ï¼‰
        incoming = self.query_relations(project_id=project_id, target_id=entity_id)

        # è·å–å®ä½“è¯¦æƒ…
        def _get_entity_info(entity_id: str) -> Dict:
            entity = self.query_entity(project_id, entity_id)
            if entity:
                return {
                    "entity_id": entity.entity_id,
                    "name": entity.name,
                    "type": entity.entity_type,
                    "file_path": entity.file_path
                }
            return {"entity_id": entity_id, "name": "unknown"}

        return {
            "entity": _get_entity_info(entity_id),
            "depends_on": [
                {
                    "target": _get_entity_info(rel.target_id),
                    "relation_type": rel.relation_type
                }
                for rel in outgoing
            ],
            "depended_by": [
                {
                    "source": _get_entity_info(rel.source_id),
                    "relation_type": rel.relation_type
                }
                for rel in incoming
            ]
        }

    def query_architecture(self, project_id: str) -> Dict[str, Any]:
        """æŸ¥è¯¢é¡¹ç›®æ¶æ„"""

        project = self.db.query(CodeProject).filter_by(project_id=project_id).first()
        if not project:
            return {"error": "Project not found"}

        # ç»Ÿè®¡å„ç±»å‹å®ä½“
        entity_stats = {}
        for entity_type in ["class", "function", "method", "module"]:
            count = self.db.query(CodeEntityModel).filter_by(
                project_id=project_id,
                entity_type=entity_type
            ).count()
            entity_stats[entity_type] = count

        # ç»Ÿè®¡å„ç±»å‹å…³ç³»
        relation_stats = {}
        for rel_type in ["calls", "imports", "inherits", "contains"]:
            count = self.db.query(CodeRelationModel).filter_by(
                project_id=project_id,
                relation_type=rel_type
            ).count()
            relation_stats[rel_type] = count

        # è·å–æ‰€æœ‰æ–‡ä»¶
        files = self.db.query(CodeEntityModel.file_path).filter_by(
            project_id=project_id
        ).distinct().all()

        # æŒ‰ç›®å½•åˆ†ç»„
        file_tree = {}
        for (file_path,) in files:
            parts = file_path.split('/')
            current = file_tree
            for part in parts[:-1]:
                if part not in current:
                    current[part] = {}
                current = current[part]
            current[parts[-1]] = None  # æ–‡ä»¶èŠ‚ç‚¹

        return {
            "project": {
                "project_id": project.project_id,
                "name": project.name,
                "language": project.language,
                "total_files": project.total_files,
                "total_lines": project.total_lines,
                "total_entities": project.total_entities,
                "total_relations": project.total_relations,
                "status": project.status,
                "analyzed_at": project.analyzed_at.isoformat() if project.analyzed_at else None
            },
            "entity_stats": entity_stats,
            "relation_stats": relation_stats,
            "file_tree": file_tree
        }

    def search_by_name(self, project_id: str, name: str, fuzzy: bool = True) -> List[CodeEntityModel]:
        """æŒ‰åç§°æœç´¢å®ä½“"""
        query = self.db.query(CodeEntityModel).filter_by(project_id=project_id)

        if fuzzy:
            query = query.filter(CodeEntityModel.name.like(f"%{name}%"))
        else:
            query = query.filter_by(name=name)

        return query.all()


# ==================== æµ‹è¯•ä»£ç  ====================

def test_storage():
    """æµ‹è¯•å­˜å‚¨åŠŸèƒ½"""
    from sqlalchemy import create_engine
    from sqlalchemy.orm import sessionmaker

    # åˆ›å»ºæ•°æ®åº“è¿æ¥
    engine = create_engine("mysql+pymysql://root:Wxwy.2025%40%23@localhost:3306/mcp_db?charset=utf8mb4")
    Base.metadata.create_all(engine)

    SessionLocal = sessionmaker(bind=engine)
    db = SessionLocal()

    # åˆ›å»ºæœåŠ¡
    service = CodeKnowledgeGraphService(db)

    # æµ‹è¯•åˆ›å»ºé¡¹ç›®
    project = service.create_project(
        project_id="test_project_001",
        name="Test Project",
        path="/test/path"
    )

    print(f"âœ“ é¡¹ç›®åˆ›å»ºæˆåŠŸ: {project.project_id}")

    db.close()


if __name__ == "__main__":
    test_storage()
